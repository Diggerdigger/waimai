接口中的方法均为公共访问的抽象方法；
接口中无法定义普通的成员变量；
接口可以定义变量，但是必须有固定的public static final修饰符修饰，所以接口中的变量也称为常量
接口中方法的固定修饰符 public abstract，可省略
接口中的每个成员变量都默认使用public static final修饰，已是静态常量，由于接口没有构造方法，所以必须显式赋值
类只能单继承，接口可以多继承，由于接口中的是抽象方法，子类实现也不会发生调用的不确定性

面向对象三大特征：封装，继承，多态

多态最近体现为父类引用变量可以指向子类对象
多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态
在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法

子父类出现同名的成员变量(编译看左，运行看左)，多态调用该变量时时调用引用型变量（等号左右，是父类引用就调用父类的，是子类引用就调用子类的，父类就算是null也不会调用子类的）所属的类中的成员变量
子父类出现同名的成员方法(编译看左，运行看右)

final修饰的类不可以被继承，但可以继承其他的类
final修饰的方法不科被子类覆盖，但父类没有final修饰的方法可以在子类中加final修饰
final修饰的变量称为常量，这些变量只能被赋值一次，编译生成.class文件后，该变量变为常量值
final修饰成员变量，需要在创建对象前赋值，否则报错（没有显式赋值时，多个构造方法均需为其赋值）
final修饰引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性可以修改

static静态内容时优先于对象存在，只能访问静态，不能使用this/super。
同一个类中，静态成员只能访问静态成员
main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中

构造代码块是定义在类中成员位置的代码块（没有static），优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作
每创建一个对象均会执行一次构造代码块

静态代码块是定义在类中成员位置的代码块，使用static修饰，优先于主方法，代码块执行，当以任意形式第一次使用到该类时执行
不管创建多少次，静态代码块只会执行一次。可用于给静态变量赋值，用来给类进行初始化

String s3="abc" 在内存中只有一个对象，这个对象在字符串常量池中
String s4=new String("abc") 在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中

StringBuilder比StringBuffer快，StringBuffer比StringBuilder安全？

子类覆盖父类方法时，子类声明的异常只能是父类声明的异常，或者其声明的子类，或者不声明
如果父类或者接口中没有声明异常，实现的子类覆盖方法发生了异常，子类方法无法进行throws声明，只能catch捕获处理，如果处理不了，在catch
中继续thorw抛出，但是异常只能转成RuntimeException子类抛出

transient和static修饰的变量不能被序列化

Runnable接口对线程对象和线程任务进行解耦

线程安全问题都是由全局变量及静态变量引起的（或者由数据库中的数据引起？）
wait()notify()notifyAll()这些方法都是在同步中才有效，同时在使用时必须标明所属锁
同步代码块的锁对向可以是任意的对象
同步方法中的锁对象是this
静态同步方法中的锁对象是 类对象 类名.class

反射可用于泛型擦除
在java中Class.forName()和ClassLoader都可以对类进行加载。ClassLoader就是遵循双亲委派模型最终调用启动类加载器的类加载器，
实现的功能是“通过一个类的全限定名来获取描述此类的二进制字节流”，获取到二进制流后放到JVM中。Class.forName()方法实际上也是调用的CLassLoader来实现的。
Class.forName加载类时将类进了初始化，而ClassLoader的loadClass并没有对类进行初始化，只是把类加载到了虚拟机中。
Spring框架中的IOC的实现就是使用的ClassLoader
使用JDBC时通常是使用Class.forName()方法来加载数据库连接驱动。这是因为在JDBC规范中明确要求Driver(数据库驱动)类必须向DriverManager注册自己。

在ssh2 项目中，struts2的action交由spring管理的时候，spring默认是singleton的，而struts2的action显然是有状 态的，
所以必须显示设置为scope="prototype"，prototype为原型模式，每次action请求过来都会创建一个action。但是对那些Dao的实现类推介
scope="singleton" ，因为这些类没有状态，用singleton只需维护一个实例，显然性能高一些